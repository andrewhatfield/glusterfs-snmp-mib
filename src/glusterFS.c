/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "glusterFS.h"
#include "glusterFS_checkfns.h"
#include "glusterFS_access.h"

static netsnmp_oid_stash_node *undoStorage = NULL;
static netsnmp_oid_stash_node *commitStorage = NULL;

long   nodeNumber = 0;
long   volumeNumber = 0;

struct undoInfo {
    void           *ptr;
    size_t          len;
};

struct commitInfo {
    void           *data_context;
    int             have_committed;
    int             new_row;
};

void
glusterFS_free_undoInfo(void *vptr)
{
    struct undoInfo *ui = vptr;
    if (!ui)
        return;
    SNMP_FREE(ui->ptr);
    SNMP_FREE(ui);
}

/** Initialize the nodeTable table by defining its contents and how it's structured */
void
initialize_table_nodeTable(void)
{
    const oid       nodeTable_oid[] = { 1, 3, 6, 1, 4, 1, 2312, 11, 2 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    DEBUGMSGTL(("glusterFS:init", "initializing table nodeTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("nodeTable",
                                                     nodeTable_handler,
                                                     nodeTable_oid,
                                                     OID_LENGTH
                                                     (nodeTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_nodeTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
                                               /** index: nodeIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = 1;
    table_info->max_column = 3;

    /** iterator access routines */
    iinfo->get_first_data_point = nodeTable_get_first_data_point;
    iinfo->get_next_data_point = nodeTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = nodeTable_context_convert_function;
    iinfo->free_data_context = nodeTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = nodeTable_loop_free;
    iinfo->free_loop_context_at_end = nodeTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_nodeTable",
                "Registering table nodeTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** Initialize the volumeTable table by defining its contents and how it's structured */
void
initialize_table_volumeTable(void)
{
    const oid       volumeTable_oid[] = { 1, 3, 6, 1, 4, 1, 2312, 11, 4 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    DEBUGMSGTL(("glusterFS:init", "initializing table volumeTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("volumeTable",
                                                     volumeTable_handler,
                                                     volumeTable_oid,
                                                     OID_LENGTH
                                                     (volumeTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_volumeTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
                                               /** index: volumeIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = 1;
    table_info->max_column = 5;

    /** iterator access routines */
    iinfo->get_first_data_point = volumeTable_get_first_data_point;
    iinfo->get_next_data_point = volumeTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = volumeTable_context_convert_function;
    iinfo->free_data_context = volumeTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = volumeTable_loop_free;
    iinfo->free_loop_context_at_end = volumeTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_volumeTable",
                "Registering table volumeTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

void
initialize_scalar_nodeNumber(void)
{
	netsnmp_handler_registration *reg;
	/* FIXME We really should use a variable for the 2312 (Red HAT OID) and 11 (GlusterFS OID) rather than hard coding them here. */
    const oid       nodeNumber_oid[] = { 1, 3, 6, 1, 4, 1, 2312, 11, 1 };
    static netsnmp_watcher_info nodeNumber_winfo;
	
	DEBUGMSGTL(("glusterFS",
                "Initializing nodeNumber scalar integer.  Default value = %d\n",
                nodeNumber));
    reg = netsnmp_create_handler_registration("nodeNumber", NULL,
                                              nodeNumber_oid,
                                              OID_LENGTH(nodeNumber_oid),
                                              HANDLER_CAN_RONLY);
    netsnmp_init_watcher_info(&nodeNumber_winfo, &nodeNumber, sizeof(long),
                              ASN_INTEGER, WATCHER_FIXED_SIZE);
    if (netsnmp_register_watched_scalar(reg, &nodeNumber_winfo) < 0) {
        snmp_log(LOG_ERR, "Failed to register watched nodeNumber");
    }

}

void
initialize_scalar_volumeNumber(void)
{
	netsnmp_handler_registration *reg;
	/* FIXME We really should use a variable for the 2312 (Red HAT OID) and 11 (GlusterFS OID) rather than hard coding them here. */
    const oid       volumeNumber_oid[] = { 1, 3, 6, 1, 4, 1, 2312, 11, 3 };
    static netsnmp_watcher_info volumeNumber_winfo;

	DEBUGMSGTL(("glusterFS",
                "Initializing volumeNumber scalar integer.  Default value = %d\n",
                volumeNumber));
    reg = netsnmp_create_handler_registration("volumeNumber", NULL,
                                              volumeNumber_oid,
                                              OID_LENGTH(volumeNumber_oid),
                                              HANDLER_CAN_RONLY);
    netsnmp_init_watcher_info(&volumeNumber_winfo, &volumeNumber,
                              sizeof(long), ASN_INTEGER,
                              WATCHER_FIXED_SIZE);
    if (netsnmp_register_watched_scalar(reg, &volumeNumber_winfo) < 0) {
        snmp_log(LOG_ERR, "Failed to register watched volumeNumber");
    }
}

/** Initializes the glusterFS module */
void
init_glusterFS(void)
{

	/** from scalar/glusterFS.c
	* BEGIN */


	/*
	*      a debugging statement.  Run the agent with -DglusterFS to see
 	*      the output of this debugging statement. 
 	*/
    DEBUGMSGTL(("glusterFS", "Initializing the glusterFS module\n"));

	/* This is my alteration
	 * BEGIN */
	initialize_scalar_nodeNumber();
	initialize_scalar_VolumeNumber();
	/* END */
	/* END
	* from scalar/glusterFS.c **/



  /** here we initialize all the tables we're planning on supporting */
    initialize_table_nodeTable();
    initialize_table_volumeTable();

	DEBUGMSGTL(("glusterFS", "Done initalizing glusterFS module\n"));
}

/** handles requests for the nodeTable table, if anything else needs to be done */
int
nodeTable_handler(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void           *data_context = NULL;

    /** column and row index encoded portion */
    const oid      *const suffix =
        requests->requestvb->name + reginfo->rootoid_len + 1;
    const size_t    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);

    DEBUGMSGTL(("glusterFS:handler", "Processing request (%d)\n",
                reqinfo->mode));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_NODEINDEX:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval = get_nodeIndex(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 retval, retval_len);
                }
                break;

            case COLUMN_NODEVERSION:
                {
                    char           *retval;
                    size_t          retval_len = 0;
                    retval = get_nodeVersion(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 retval, retval_len);
                }
                break;

            case COLUMN_BRICKNUMBER:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval = get_brickNumber(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 retval, retval_len);
                }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in nodeTable_handler: unknown column\n");
            }
            break;


        default:
            snmp_log(LOG_ERR,
                     "problem encountered in nodeTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the volumeTable table, if anything else needs to be done */
int
volumeTable_handler(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void           *data_context = NULL;

    /** column and row index encoded portion */
    const oid      *const suffix =
        requests->requestvb->name + reginfo->rootoid_len + 1;
    const size_t    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);

    DEBUGMSGTL(("glusterFS:handler", "Processing request (%d)\n",
                reqinfo->mode));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_VOLUMEINDEX:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval = get_volumeIndex(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 retval, retval_len);
                }
                break;

            case COLUMN_VOLUMENAME:
                {
                    char           *retval;
                    size_t          retval_len = 0;
                    retval = get_volumeName(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 retval, retval_len);
                }
                break;

            case COLUMN_VOLUMETYPE:
                {
                    char           *retval;
                    size_t          retval_len = 0;
                    retval = get_volumeType(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 retval, retval_len);
                }
                break;

            case COLUMN_VOLUMESTATUS:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval = get_volumeStatus(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 retval, retval_len);
                }
                break;

            case COLUMN_VOLUMEBRICKNUMBER:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_volumeBrickNumber(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 retval, retval_len);
                }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in volumeTable_handler: unknown column\n");
            }
            break;


        default:
            snmp_log(LOG_ERR,
                     "problem encountered in volumeTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}
