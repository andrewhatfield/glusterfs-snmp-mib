/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "nodes.h"

/*
 * nodes_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             nodes_variables_oid[] = { 1, 3, 6, 1, 4, 1, 2312, 11 };

/*
 * variable4 nodes_variables:
 *   this variable defines function callbacks and type return information 
 *   for the nodes mib section 
 */

struct variable4 nodes_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */
#define NODENUMBER		1
    {NODENUMBER, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_nodes, 1, {1}},

#define NODEINDEX		1
    {NODEINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_nodeTable, 3, {2, 1, 1}},
#define NODEVERSION		2
    {NODEVERSION, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_nodeTable, 3, {2, 1, 2}},
};

/*
 * (L = length of the oidsuffix) 
 */


/** Initializes the nodes module */
void
init_nodes(void)
{

    DEBUGMSGTL(("nodes", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree 
     */
    REGISTER_MIB("nodes", nodes_variables, variable4, nodes_variables_oid);

    /*
     * place any other initialization junk you need here 
     */
}

/*
 * var_nodes():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_nodes(struct variable *vp,
          oid * name,
          size_t *length,
          int exact, size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case NODENUMBER:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_nodeTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_nodes above.
 */
unsigned char  *
var_nodeTable(struct variable *vp,
              oid * name,
              size_t *length,
              int exact, size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case NODEINDEX:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case NODEVERSION:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}
